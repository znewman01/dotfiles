#+TITLE: Doom Emacs Config
#+PROPERTY: header-args:emacs-lisp :noweb yes :results none :tangle config.el

* Preliminaries
Use [[https://www.emacswiki.org/emacs/LexicalBinding][lexical binding]]:
#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

Make the ~doom~ CLI tool work (hack due to Nix chicanery):
#+begin_src emacs-lisp
(setenv "EMACSDIR" "~/.emacs.d")
#+end_src

Docs working:
#+begin_src emacs-lisp
(setq doom-modules-dir (car doom-modules-dirs)
      doom-docs-dir (car doom-modules-dirs))
#+end_src

And some PII to put in my [[github:znewman01/dotfiles][dotfiles]]:
#+begin_src emacs-lisp
(setq user-full-name "Zachary Newman"
      user-mail-address "z@znewman.net")
#+end_src

Take a hint from Vim on to extra key commands (use ~,~).
#+begin_src emacs-lisp
(setq doom-localleader-key ",")
#+end_src

And make an insert-mode leader that doesn't conflict with XMonad:
#+begin_src emacs-lisp
(setq doom-leader-alt-key "s-SPC")
(setq doom-localleader-alt-key "s-SPC m")
#+end_src

Live dangerously (I like to put as much config as possible locally):

#+begin_src emacs-lisp
(setq enable-local-variables t)
#+end_src

Nice imports:

#+begin_src emacs-lisp
(require 'url)
(require 'cl-lib)
(require 'f)
(require 's)
(require 'dash)
(require 'json)
#+end_src
* Utilities
A smart person once told me: if you have to call a unit of code "util" or "lib", you haven't thought very hard about how to structure your program.
** IACR ePrints
I read a lot of papers from the [[https://eprint.iacr.org/][IACR ePrint Archive]] and wrote a [[github:znewman01/iacr-dl][Python tool]] for interacting with it programatically. We use it in a couple of places ([[org]], [[Bibliography]]) so it needs to be somewhere common.
#+begin_src emacs-lisp
(defun zjn--fetch-iacr-info (id)
  (require 'json)
  (let* ((default-directory "~/git/iacr-dl")
         (blob (car (process-lines "nix-shell" "--run" (concat "python -m iacr " id))))
         (json-object-type 'alist)
         (json-array-type 'list)
         (json-key-type nil))
    (json-read-from-string blob)))
#+end_src
** Passwords
I use the [[https://www.passwordstore.org/][standard Unix password store]], which is quite nice for authorizing CLI/editor tools.
#+begin_src emacs-lisp
(defun zjn--password (name)

  ; sh is to work around "gpg: selecting card failed" issue
  (car (process-lines "sh" "-c" "pass show instapaper 2>/dev/null")))
#+end_src
** Instapaper
Send URLs to [[https://www.instapaper.com/][Instapaper]] for offline reading.
#+begin_src emacs-lisp
(defun zjn--add-to-instapaper (url success-callback)
  (require 'request)
  (let* ((username "znewman01@gmail.com")
         (password (zjn--password "instapaper")))
    (request "https://www.instapaper.com/api/add"
      :params `(("url" . ,url)
                ("username" . ,username)
                ("password" . ,password))
      :success success-callback
      :error (cl-function
              (lambda (&key error-thrown &allow-other-keys)
                (warn "Issue adding to Instapaper! %S" error-thrown))))))
#+end_src
** Searching
I like to search using DDG always:
#+begin_src emacs-lisp
(defun zjn--search-in-firefox-inner (default-text force-edit-text &optional prefix)
  (let* ((edit-text (or (s-blank? default-text) force-edit-text))
         (initial-position (if (s-blank? prefix) (length default-text) (length prefix)))
         (default-text (s-concat prefix default-text))
         (search-string (if edit-text (read-string "search string: " (cons default-text initial-position)) default-text))
         (url (s-concat "https://duckduckgo.com/?t=ffab&q=" (url-encode-url search-string))))
    (call-process "xdg-open" nil nil nil url)))

(defun zjn--current-region ()
  (if (doom-region-active-p) (buffer-substring (mark) (point)) ""))

(defun zjn--search-in-firefox (edit-text)
  (interactive "P")
  (zjn--search-in-firefox-inner (zjn--current-region) edit-text))

(defun zjn--search-in-firefox-bang (edit-text)
  (interactive "P")
  (zjn--search-in-firefox-inner (zjn--current-region) edit-text "! "))

(map! :leader
      (:prefix ("s" . "search")
       :desc "Search in DDG" "o" #'zjn--search-in-firefox
       :desc "Search in DDG (!)" "O" #'zjn--search-in-firefox-bang))
#+end_src
* org
:PROPERTIES:
:header-args: :noweb-ref org
:END:
#+begin_src emacs-lisp :noweb-ref nil
(after! org
  (require 'org-ql)
  (require 'org-super-agenda)
  (require 'org-attach)
  (require 'org-capture)
  <<org>>)
#+end_src
** Tagging and task mgmt
#+begin_src emacs-lisp :tangle no
(setq org-log-done t)
(setq org-log-state-notes-into-drawer t)
(setq org-todo-keywords
      '((sequence "NEXT(n)" "BUY" "TODO(t)" "|" "DONE(d!)")
        (sequence "HABIT(h)" "|" "HABITDONE(H)")
        (sequence "PROJ(p)" "BLOCKEDPROJ(b)" "|" "PROJDONE(P)")
        (sequence "WAITING(w)" "SOMEDAY(s)" "|" "CANCELLED(c)")))
(setq org-enforce-todo-dependencies nil)
(setq org-tag-persistent-alist '((:startgroup . nil)
                                 ("@errand" . ?e)
                                 ("@home" . ?h)
                                 ("@campus" . ?c)
                                 (:endgroup . nil)
                                 ("internet" . ?i)
                                 ("code" . nil)
                                 ("gradschool" . ?g)
                                 ("personal" . ?p)
                                 ("katie" . ?k)))
#+end_src
*** Org files+general config
#+begin_src emacs-lisp :tangle no
(setq org-directory "~/notes")
(defun org-file (f)
  (concat org-directory "/" f))
(setq org-agenda-files
      (mapcar #'org-file
              '("personal.org"
                "gtd.org"
                "projects.org"
                "chainguard.org"
                "research/default.org"
                "research/broadcast.org"
                "research/accumulators.org"
                "research/tor.org"
                "inbox-mac.org"
                "school.org")))
(setq org-archive-location "archive/%s::")
(setq org-attach-directory (org-file ".attach"))
(setq org-attach-id-dir (org-file ".attach"))
(setq org-default-notes-file (org-file "gtd.org"))
(setq org-id-locations-file (org-file ".org-id-locations"))
#+end_src

*** Agenda
#+begin_src emacs-lisp :noweb-ref nil
(after! org-super-agenda
  (require 'evil-org-agenda)
  (org-super-agenda-mode)
  (setq org-super-agenda-header-map evil-org-agenda-mode-map) ; https://github.com/alphapapa/org-super-agenda/issues/50
  (setq org-super-agenda-header-map (make-sparse-keymap))
  (setq org-agenda-prefix-format '((agenda . " %?-12t% s")
                                   (timeline . "  % s")
                                   (todo . "")
                                   (tags . "")
                                   (search . "g%-8:e")))

  (setq org-agenda-custom-commands
    (let ((agenda-common
           '(agenda ""
                    ((org-agenda-span 'day)
                     (org-agenda-start-day "+0d")
                     (org-agenda-skip-timestamp-if-done t)
                     (org-agenda-skip-scheduled-if-done t)
                     (org-agenda-skip-deadline-if-done t)
                     (org-super-agenda-groups '((:discard (:not (:time-grid t)))
                                                (:name "Agenda:" :time-grid t))))))
          (stuck-common
           '(org-ql-block '(and
                            (not (tags "SOMEDAY"))
                            (or (and (todo "PROJ")
                                     (not (descendants (todo "NEXT"))))
                                (and (todo "BLOCKEDPROJ")
                                     (not (scheduled t))
                                     (not (deadline t)))
                                (and (todo "WAITING")
                                     (not (or (scheduled t) (deadline t))))
                                (and (todo "SOMEDAY")
                                     (not (tags "SOMEDAY")))
                                (and (todo "TODO")
                                     (not (ancestors (todo "PROJ" "BLOCKEDPROJ"))))))
                          ((org-ql-block-header "Stuck projects:"))))
          (tasks-common
           (lambda (desc)
             `(org-ql-block '(and
                             (or (and (todo "NEXT") (not (tags "SOMEDAY")))
                                 (deadline auto)
                                 (scheduled :to today))
                             (not (done))
                             (not (scheduled :on today :with-time t)))
                              ((org-super-agenda-groups '((:discard (:time-grid t))
                                                          (:name "Overdue:"
                                                                 :deadline past)
                                                          (:name "Upcoming:"
                                                                 :deadline future
                                                                 :deadline today)
                                                          (:name "Habits"
                                                                 :todo "HABIT")
                                                          (:name "Scheduled:"
                                                                 :scheduled past
                                                                 :scheduled today)
                                                          (:name "Work:"
                                                                 :tag "chainguard")
                                                          (:name "Errands:" :order 1
                                                                 :tag "@errand")
                                                          (:name "Home:" :order 1
                                                                 :tag "@home")
                                                          (:discard (:tag "yak"))
                                                          (:name "Other tasks:"
                                                                 :anything t)))
                               (org-ql-block-header ,(concat desc " tasks:")))))))
      `(("nw" "Work"
         (,agenda-common
          ,stuck-common
          ,(funcall tasks-common "Chainguard"))
         ((org-agenda-tag-filter-preset '("+chainguard"))))
        ("na" "All"
         (,agenda-common
          ,stuck-common
          ,(funcall tasks-common "All"))))))

  ; https://lists.gnu.org/archive/html/emacs-orgmode/2015-06/msg00266.html
  (defun org-agenda-delete-empty-blocks ()
    "Remove empty agenda blocks.
  A block is identified as empty if there are fewer than 2
  non-empty lines in the block (excluding the line with
  `org-agenda-block-separator' characters)."
    (when org-agenda-compact-blocks
      (user-error "Cannot delete empty compact blocks"))
    (setq buffer-read-only nil)
    (save-excursion
      (goto-char (point-min))
      (let* ((blank-line-re "^\\s-*$")
             (content-line-count (if (looking-at-p blank-line-re) 0 1))
             (start-pos (point))
             (block-re (format "%c\\{10,\\}" org-agenda-block-separator)))
        (while (and (not (eobp)) (forward-line))
          (cond
           ((looking-at-p block-re)
            (when (< content-line-count 2)
              (delete-region start-pos (1+ (point-at-bol))))
            (setq start-pos (point))
            (forward-line)
            (setq content-line-count (if (looking-at-p blank-line-re) 0 1)))
           ((not (looking-at-p blank-line-re))
            (setq content-line-count (1+ content-line-count)))))
        (when (< content-line-count 2)
          (delete-region start-pos (point-max)))
        (goto-char (point-min))
        ;; The above strategy can leave a separator line at the beginning
        ;; of the buffer.
        (when (looking-at-p block-re)
          (delete-region (point) (1+ (point-at-eol))))))
    (setq buffer-read-only t))
  (add-hook 'org-agenda-finalize-hook #'org-agenda-delete-empty-blocks))
#+end_src
*** Capture
#+begin_src emacs-lisp :tangle no
(setq org-capture-templates nil)
(push '("l" "Link to current file" entry
        (file+headline "~/notes/gtd.org" "Inbox")
        "** NEXT %?\n%a\n%i\n")
      org-capture-templates)

(push '("t" "Normal TODO" entry
        (file+headline "~/notes/gtd.org" "Inbox")
        "** NEXT %?\n")
      org-capture-templates)
#+end_src
** Global org settings
#+begin_src emacs-lisp :tangle no
(add-hook 'auto-save-hook 'org-save-all-org-buffers)
(setq org-adapt-indentation nil)
(setq org-ctrl-k-protect-subtree t)
(setq org-catch-invisible-edits 'show-and-error)
(setq org-startup-indented nil)
(setq org-startup-folded 'fold)
(setq org-show-context-detail
    (quote
        ((agenda . ancestors)
        (bookmark-jump . ancestors)
        (isearch . ancestors)
        (default . ancestors))))
(advice-add 'org-id-new :filter-return #'upcase)
#+END_SRC
*** Performance
#+begin_src emacs-lisp :tangle no
(setq org-agenda-dim-blocked-tasks nil
    org-agenda-inhibit-startup t
    org-agenda-ignore-properties '(effort appt stat category))
#+end_src
*** Aesthetics

From a [[https://zzamboni.org/post/beautifying-org-mode-in-emacs/][blog]]:
#+begin_src :tangle no
(setq org-hide-emphasis-markers t)
#+end_src
*** Math
#+begin_src emacs-lisp :tangle no
(setq org-startup-with-latex-preview nil)
(require 'org-fragtog)
(add-hook 'org-mode-hook 'org-fragtog-mode)
#+end_src

** Reference management
#+begin_src emacs-lisp :tangle no
(require 'org-ref)
#+end_src
*** Org-cite
#+begin_src emacs-lisp :noweb-ref nil
(after! oc
    (setq org-cite-global-bibliography '("~/notes/lit/default.bib"))
    (org-link-set-parameters "cite" :display 'org-link))
#+end_src
*** IACR
#+begin_src emacs-lisp :tangle no
(defun zjn--import-iacr (id)
  (interactive "sIACR ePrint ID? ")
  (let* ((article (zjn--fetch-iacr-info id))
         (download-fname (format "iacr:%s.pdf" (s-replace "/" ":" (alist-get 'id article))))
         (download-path (f-join bibtex-completion-library-path download-fname))
         (fixed-bibtex (s-replace "cryptoeprint" "iacr" (alist-get 'bibtex article))))
    (message "Found %s." (alist-get 'id article))
    (write-region fixed-bibtex nil bibtex-completion-bibliography 'append)
    (url-copy-file (alist-get 'pdf_link article) download-path t)
    (bibtex-completion-clear-cache)))

(defun zjn--format-iacr-org (region)
  (let* ((id (if (string-empty-p region)
                 (read-string "IACR ePrint ID (ex. 2019/001)? ")
               region))
         (json-string (zjn--fetch-iacr-info id))
         (json-object-type 'hash-table)
         (json-array-type 'list)
         (json-key-type 'string)
         (article (json-read-from-string json-string)))
    (save-excursion
      (org-back-to-heading t)
      (end-of-line)
                                      ; Use insert rather than the format string so we don't clobber the article
                                      ; attachment
      (insert (gethash "title" article)
              "\nhttps://eprint.iacr.org/"
              (gethash "id" article)
              "\nAuthor(s): "
              (mapconcat 'identity (gethash "authors" article) ", ")
              "\n#+BEGIN_SRC bibtex\n"
              (gethash "bibtex" article)
              "#+END_SRC"))
    (org-attach-attach (gethash "pdf_link" article) nil 'url))
    "")  ; needs to return string to satisfy org-capture

(push '("i" "IACR" entry (file+headline "~/notes/research/default.org" "Paper queue")
        "* %(zjn--format-iacr-org \"%i\")\n")
      org-capture-templates)
#+end_src
*** arXiv
#+begin_src emacs-lisp :tangle no
; Doesn't handle authors with non-ASCII names....
(defun zjn--format-arxiv-org (region)
  (let* ((id (if (string-empty-p region)
                 (read-string "arXiv ID (ex. 1905.11379)? ")
               region))
         (api-url (format "http://export.arxiv.org/api/query?id_list=%s" id)))
    (request
     api-url
     :parser (lambda () (libxml-parse-xml-region (point) (point-max)))
     :success
     (cl-function
      (lambda (&key data &allow-other-keys)
        (let* ((entry (car (xml-get-children data 'entry)))
               (title (replace-regexp-in-string " *\n *" " " (caddar (xml-get-children entry 'title))))
               (authors (mapconcat (lambda (x) (caddr (caddr x)))
                                   (xml-get-children entry 'author) ", "))
               (pdf-link
                (concat (cdr
                         (assoc 'href
                                (cadar
                                 (cl-remove-if-not
                                  (lambda (x)
                                    (string= (cdr (assoc 'title (cadr x))) "pdf"))
                                  (xml-get-children entry 'link)))))
                        ".pdf"))
               (article-link
                (cdr (assoc 'href (cadar
                                   (cl-remove-if-not
                                    (lambda (x)
                                      (string= (cdr (assoc 'rel (cadr x))) "alternate"))
                                    (xml-get-children entry 'link)))))))
          (save-excursion
            (org-back-to-heading t)
            (end-of-line)
            (insert title
                    "\n"
                    article-link
                    "\nAuthor(s): "
                    authors)
            (sit-for 0.1)
            (org-attach-attach pdf-link nil 'url)))))))
  "")
#+end_src
** Anki
#+begin_src emacs-lisp :tangle no
(require 'org-anki)
(setq org-anki-default-deck "Default")
#+end_src
** Keybindings
Need to be global, not ~(after! org)~.
#+begin_src emacs-lisp :noweb-ref nil
(map! :leader "a" (cmd! (org-agenda nil "nw")))
(map! :mode org-capture-mode :localleader "s r" #'org-capture-refile)
(map! :mode org-mode :n "t" #'org-todo)
(map! :map org-agenda-mode-map :localleader "." #'counsel-org-goto-all
    :localleader "/" #'counsel-org-goto-all)
(map! :leader "s /" #'counsel-org-goto-all)
#+end_src
** org-babel
Easier NixOS and org-babel integration:
#+begin_src emacs-lisp :noweb-ref nil
(defun zjn/with-pkgs (interpreter &rest pkgs)
  (s-concat
    "#!/usr/bin/env nix-shell\n"
     "#!nix-shell -p " (s-join " " pkgs) " -i " interpreter))
(defun zjn/with-pkgs-bash (&rest pkgs)
  (apply #'zjn/with-pkgs (cons "bash" pkgs)))
#+end_src

Use like so:

#+begin_example
#+begin_src bash :shebang (zjn/with-pkgs-bash "hello") :results verbatim
hello
#+end_src

#+RESULTS:
: Hello, world!
#+end_example
** Export
#+begin_src
(setq org-preview-latex-default-process 'imagemagick)
                                      ; (plist-put org-format-latex-options :background "Transparent")
(setq org-latex-pdf-process '("tectonic %f"))
#+end_src
** org-roam
#+begin_src emacs-lisp :noweb-ref nil
(after! org-roam
  (setq org-roam-directory "~/Sync/notes/roam"
        org-roam-completion-everywhere nil
        +org-roam-open-buffer-on-find-file nil))
#+end_src
* Bibliography
Eventually will sort through this.
#+begin_src emacs-lisp
(use-package! org-roam-bibtex
  :after org-roam oc
  :config
    (setq orb-roam-ref-format 'org-cite)
    (setq bibtex-completion-bibliography "~/Sync/notes/lit/default.bib"
        bibtex-completion-library-path "~/Sync/notes/lit/"
        bibtex-completion-notes-path "~/Sync/notes/roam/bib/")
    (require 'citar-org-roam)
    (citar-register-notes-source
     'orb-citar-source (list :name "Org-Roam Notes"
                             :category 'org-roam-node
                             :items #'citar-org-roam--get-candidates
                             :hasitems #'citar-org-roam-has-notes
                             :open #'citar-org-roam-open-note
                             :create #'orb-citar-edit-note
                             :annotate #'citar-org-roam--annotate))
    (setq citar-notes-source 'orb-citar-source))
(use-package! citar
  :after org-roam oc
  :config
  (setq org-cite-insert-processor 'citar
        org-cite-follow-processor 'citar
        org-cite-activate-processor 'citar
        citar-bibliography org-cite-global-bibliography
        citar-library-paths '("~/Sync/notes/lit"))
  (map!
   :leader
   "n b" #'citar-open
   :mode org
   "C-c b" #'org-cite-insert))
#+end_src
* Mail
:PROPERTIES:
:header-args: :noweb-ref mu4e
:END:
I use [[https://www.djcbsoftware.nl/code/mu/][mu]] for mail, and "~mu~ for Emacs" (~mu4e~) for mail for Emacs:
#+begin_src emacs-lisp :noweb-ref nil
(when (executable-find "mbsync")
  (eval-and-compile
    (defun mu4e-load-path ()
      (f-join (string-trim (shell-command-to-string "nix-store -r $(which mu) 2> /dev/null")) "share/emacs/site-lisp/mu4e")))
  (use-package! mu4e
    :load-path (lambda () (list (mu4e-load-path)))
    :config
    <<mu4e>>))
#+end_src

Tell Emacs I want to use ~mu4e~ for sending mail:
#+begin_src emacs-lisp :tangle no
(setq mail-user-agent 'mu4e-user-agent)
(setq message-send-mail-function 'smtpmail-send-it)
#+end_src

Tell ~mu4e~ how to find my mail:
#+begin_src emacs-lisp :tangle no
(setq mu4e-root-maildir "~/Maildir")
(setq mu4e-get-mail-command "mbsync -a")
#+end_src

Make it a little faster (must run ~mu index~ every once in a while to reindex):
#+begin_src emacs-lisp :tangle no
(setq mu4e-index-cleanup t      ;; don't do a full cleanup check
      mu4e-index-lazy-check nil)
#+end_src

I forget why this is here:
#+begin_src emacs-lisp :tangle no
(setq mu4e-completing-read-function 'completing-read)
#+end_src

Quit, dang it!
#+begin_src emacs-lisp :tangle no
(setq mu4e-confirm-quit nil)
#+end_src
** Accounts
#+begin_src emacs-lisp :tangle no
(setq auth-source-save-behavior nil)
(setq mu4e-context-policy 'pick-first)
(defmacro zjn--make-match (folder)
  `(lambda (msg)
      (when msg
          (string-prefix-p ,(concat "/" folder)
                        (mu4e-message-field msg :maildir)))))
(require 'mu4e-context)
(setq mu4e-contexts
      `(
        ,(make-mu4e-context
          :name "Fastmail"
          :match-func (zjn--make-match "fastmail")
          :vars '((mu4e-trash-folder . "/fastmail/Trash")
                  (mu4e-sent-folder . "/fastmail/Sent")
                  (mu4e-drafts-folder . "/fastmail/Drafts")
                  (mu4e-refile-folder . "/fastmail/Archive")
                  (user-mail-address . "z@znewman.net")
                  (user-full-name . "Zachary Newman")
                  (smtpmail-local-domain . "znewman.net")
                  (smtpmail-smtp-server . "smtp.fastmail.com")
                  (smtpmail-stream-type . ssl)
                  (smtpmail-smtp-service . 465)))
        ,(make-mu4e-context
          :name "MIT"
          :match-func (zjn--make-match "mit")
          :vars '((mu4e-trash-folder . "/mit/Deleted")
                  (mu4e-sent-folder . "/mit/Sent")
                  (mu4e-drafts-folder . "/mit/Drafts")
                  (mu4e-refile-folder . "/mit/Archive")
                  (user-mail-address . "zjn@mit.edu")
                  (user-full-name . "Zachary Newman")
                  (smtpmail-local-domain . "mit.edu")
                  (smtpmail-smtp-server . "outgoing.mit.edu")
                  (smtpmail-stream-type . ssl)
                  (smtpmail-smtp-service . 465)))
        ,(make-mu4e-context
          :name "oCSAIL"
          :match-func (zjn--make-match "csail")
          :vars '((mu4e-trash-folder . "/csail/Trash")
                  (mu4e-sent-folder . "/csail/Sent")
                  (mu4e-drafts-folder . "/csail/Drafts")
                  (mu4e-refile-folder . "/csail/Archive")
                  (user-mail-address . "zjn@csail.mit.edu")
                  (user-full-name . "Zachary Newman")
                  (smtpmail-local-domain . "csail.mit.edu")
                  (smtpmail-smtp-server . "outgoing.csail.mit.edu")
                  (smtpmail-stream-type . starttls)
                  (smtpmail-smtp-service . 587)))
        ,(make-mu4e-context
          :name "Gmail"
          :match-func (zjn--make-match "gmail")
          :vars '((mu4e-trash-folder . "/gmail/[Gmail]/Trash")
                  (mu4e-sent-folder . "/gmail/[Gmail]/SentMail")
                  (mu4e-drafts-folder . "/gmail/[Gmail]/Drafts")
                  (mu4e-refile-folder . "/gmail/[Gmail]/AllMail")
                  (user-mail-address . "znewman01@gmail.com")
                  (smtpmail-smtp-user "znewman01@gmail.com")
                  (user-full-name . "Zachary Newman")
                  (smtpmail-local-domain . "gmail.com")
                  (smtpmail-smtp-server . "smtp.gmail.com")
                  (smtpmail-stream-type . starttls)
                  (smtpmail-smtp-service . 587)))
        ,(make-mu4e-context
          :name "Chainguard"
          :match-func (zjn--make-match "chainguard")
          :vars '((mu4e-trash-folder . "/chainguard/[Gmail]/Trash")
                  (mu4e-sent-folder . "/chainguard/[Gmail]/SentMail")
                  (mu4e-drafts-folder . "/chainguard/[Gmail]/Drafts")
                  (mu4e-refile-folder . "/chainguard/[Gmail]/AllMail")
                  (user-mail-address . "zjn@chainguard.dev")
                  (user-full-name . "Zachary Newman")
                  (smtpmail-local-domain . "gmail.com")
                  (smtpmail-smtp-user "zjn@chainguard.dev")
                  (smtpmail-smtp-server . "smtp.gmail.com")
                  (smtpmail-stream-type . starttls)
                  (smtpmail-smtp-service . 587)))))
#+end_src

** Inbox: reading and managing
Common views (combined inbox, unread, all recent):
#+begin_src emacs-lisp :tangle no
(defun zjn--get-mu4e-vars (var)
  "Get mu4e vars /in current mu4e context/"
  (mapcar (lambda (context)
            (alist-get var (mu4e-context-vars context)))
          mu4e-contexts))
(let* ((trash-folders (zjn--get-mu4e-vars 'mu4e-trash-folder))
       (sent-folders (zjn--get-mu4e-vars 'mu4e-sent-folder))
       (query-skipping
        (lambda (query maildirs)
          (s-join " AND "
                  (cons query
                        (mapcar (apply-partially #'concat "NOT maildir:") maildirs)))))
       (skip-trash-and-sent
         (lambda (query) (funcall query-skipping query (-concat trash-folders sent-folders '("/mit/Junk" "/gmail/[Gmail]/Spam" "/chainguard/[Gmail]/Spam"))))))
    (setq mu4e-bookmarks
        (mapcar (apply-partially #'apply #'make-mu4e-bookmark)
                `((:name "All Inboxes"
                    :query "maildir:/gmail/Inbox OR maildir:/mit/INBOX OR maildir:/fastmail/INBOX OR maildir:/csail/INBOX OR maildir:/chainguard/Inbox"
                    :key ?i)
                    (:name "Unread messages"
                    :query ,(funcall skip-trash-and-sent "flag:unread AND NOT flag:trashed")
                    :key ?u)
                    (:name "Last 7 days"
                    :query ,(funcall skip-trash-and-sent "date:7d..now")
                    :key ?w)))))
(setq mu4e-headers-sort-field :date)
#+end_src

Misc:
#+begin_src emacs-lisp :tangle no
(setq mu4e-attachment-dir (expand-file-name "~/zjn/Downloads"))
(mkdir mu4e-attachment-dir t)
(setq mu4e-view-show-addresses t)
(setq mu4e-change-filenames-when-moving t)
(setq nsm-settings-file (expand-file-name "~/.local/doom/network-security.data"))
#+end_src

Move to trash, don't just delete ([[http://cachestocaches.com/2017/3/complete-guide-email-emacs-using-mu-and-/][source]]):
#+begin_src emacs-lisp :tangle no
(require 'mu4e-mark)
(setf
  (alist-get 'trash mu4e-marks)
  (plist-put (cdr (assq 'trash mu4e-marks))
             :action
             (lambda (docid msg target)
               (mu4e~proc-move docid (mu4e~mark-check-target target) "-N"))))
#+end_src

Don't count deleted emails in "unread" for modeline:
#+begin_src emacs-lisp :tangle no
(setq mu4e-alert-interesting-mail-query "flag:unread AND NOT flag:trashed AND (maildir:/gmail/Inbox OR maildir:/mit/INBOX OR maildir:/fastmail/INBOX OR maildir:/csail/INBOX OR maildir:/chainguard/Inbox)")
#+end_src
** Outbox
*** Composing
[[org]] everywhere!
#+begin_src emacs-lisp :tangle no
(require 'org-mu4e)
#+end_src
Don't send prematurely by accident (this allows a neat trick of leaving the subject empty while writing mail, and filling it in only when ready):
#+begin_src emacs-lisp :tangle no
(defun zjn--confirm-empty-subject ()
  "Allow user to quit when current message subject is empty."
  (or (message-field-value "Subject")
      (yes-or-no-p "Really send without Subject? ")
      (keyboard-quit)))
(add-hook 'message-send-hook #'zjn--confirm-empty-subject)
#+end_src
And let me pick my context every time:
#+begin_src emacs-lisp :tangle no
(setq mu4e-compose-context-policy 'ask)
#+end_src
*** Sending
#+begin_src emacs-lisp :tangle no
(setq send-mail-function 'smtpmail-send-it)
#+end_src
* RSS
#+begin_src emacs-lisp
(after! elfeed
  (setq elfeed-db-directory (expand-file-name "~/Sync/elfeed"))
  (setq elfeed-enclosure-default-dir (expand-file-name "~/Sync/elfeed/enclosures"))
  (setq elfeed-feeds
        '(("http://bristolcrypto.blogspot.com/feeds/posts/default")
          ("https://www.schneier.com/blog/atom.xml")
          ("https://www.mattblaze.org/blog/rss20.xml")
          ("https://alinush.github.io/feed.xml")
          ("https://blog.chainguard.dev/rss/")
          ("https://dlorenc.medium.com/feed")
          ("https://jvns.ca/atom.xml")
          ("https://blog.cryptographyengineering.com/feed/")
          ("https://blog.techorganic.com/atom.xml")
          ("https://joy.recurse.com/feed.atom")
          ("https://blog.erratasec.com/feeds/posts/default?alt=rss")
          ("http://barrebas.github.io/atom.xml")
          ("http://paperpools.blogspot.com/feeds/posts/default")
          ("http://lambda-the-ultimate.org/rss.xml")
          ("http://feeds.feedburner.com/Fsharpforfunandprofit?format=xml")
          ("https://islandsofnewyork.blog?feed=atom")
          ("https://blog.acolyer.org/feed/")
          ("https://www.iacr.org/news/rss")
          ("https://slatestarcodex.com/feed/")
          ("http://www.christianmoscardi.com/feed.xml")
          ("https://danluu.com/atom.xml")
          ("https://mass.streetsblog.org/feed/")
          ("https://scholars-stage.org/?feed=atom")
          ("http://feeds.feedburner.com/creditslips/feed?format=xml")
          ("https://this-week-in-rust.org/atom.xml")
          ("http://squidarth.com/feed.xml")
          ("https://windowsontheory.org/feed/")
          ("https://www.interfluidity.com/feed")
          ("https://schlosser.io/rss.xml")
          ("https://blog.sigstore.dev/feed")
          ("https://weekly.nixos.org/feeds/all.rss.xml")
          ("https://qualiacomputing.com/feed/")
          ("https://vitalik.ca/feed.xml")
          ("https://www.tweag.io/rss.xml")
          ("https://algorithmsoup.wordpress.com/feed.xml")
          ("https://stefan.vanburen.xyz/blog/index.xml")
          ("https://www.scottaaronson.blog/?feed=rss2")))

  (defun elfeed-show-browse-url ()
    (interactive)
    (browse-url (elfeed-entry-link elfeed-show-entry)))

                                        ; Instapaper + Elfeed

  (defun add-elfeed-entry-to-instapaper ()
    (interactive)
    (let ((entry (elfeed-search-selected :single)))
      (zjn--add-to-instapaper
       (elfeed-entry-link entry)
       (cl-function (lambda (&key data &allow-other-keys)
                      (message "Added to Instapaper!")
                      (elfeed-untag entry 'unread)
                      (elfeed-search-update-entry entry)))))
    (unless (use-region-p) (forward-line)))

  (defun add-elfeed-shown-to-instapaper ()
    (interactive)
    (zjn--add-to-instapaper
     (elfeed-entry-link elfeed-show-entry)
     (cl-function (lambda (&key data &allow-other-keys)
                    (message "Added to Instapaper!")))))


  (require 'elfeed-db)
  (add-hook 'elfeed-show-mode-hook #'elfeed-db-save)
  (defun add-elfeed-entry-to-paper-queue-iacr ()
    (interactive)
    (let ((entry (elfeed-search-selected :single)))
      (zjn--import-iacr (elfeed-entry-link entry))
      (message "Imported IACR article!")))
  (defun add-elfeed-shown-to-paper-queue-iacr ()
    (interactive)
    (zjn--import-iacr (elfeed-entry-link elfeed-show-entry))
    (message "Imported IACR article!"))

  (map! :mode 'elfeed-search-mode
        :n "I" #'add-elfeed-entry-to-paper-queue-iacr
        :n "o" #'elfeed-search-browse-url
        :n "i" #'add-elfeed-entry-to-instapaper
        :n "u" #'elfeed-update
        :n "s" (cmd! (elfeed-db-save))

        :mode 'elfeed-show-mode
        :n "I" #'add-elfeed-shown-to-paper-queue-iacr
        :n "o" #'elfeed-show-browse-url
        :n "i" #'add-elfeed-shown-to-instapaper))
(map! :leader (:prefix-map ("o" . "open")
               :desc "RSS" "e" #'=rss))
#+end_src
* Theme
Use base16 theme; this is nice because it's easy to match with the rest of my desktop.
#+begin_src emacs-lisp
(when (file-directory-p "~/.doom-themes")
  (add-to-list 'custom-theme-load-path "~/.doom-themes")
  (setq doom-theme nil)
  (load-theme 'base16-zjn t)
  ; I want to be able to see which workspace is selected; the default highlighting is too weak.
  (set-face-background '+workspace-tab-selected-face (plist-get base16-zjn-colors :base02))
  (set-face-foreground '+workspace-tab-selected-face (plist-get base16-zjn-colors :base0D)))
#+end_src

Some reasonable fonts:
#+begin_src emacs-lisp
(when (eq system-type 'gnu/linux)
  (setq zjn--mono "Roboto Mono")
  (setq zjn--sans "Bitstream Vera Sans")
  (setq zjn--serif "TeX Gyre Pagella")
  (setq doom-font (font-spec :family zjn--mono :height 80 :weight 'semi-light))
  (setq doom-variable-pitch-font (font-spec :family zjn--serif :height 60)))
#+end_src

And some padding:
#+begin_src emacs-lisp
(setq-default left-margin-width 1
              right-margin-width 1)
#+end_src

* Do the Work
Now that that's all out of the way, we can get to actual work.
** Project Management
#+begin_src emacs-lisp
(after! projectile
  (setq projectile-project-search-path '("~/git"))
  (defun zjn-projectile-root-for-some-major-modes (_dir)
    (message "%s" major-mode)
    (let ((modes '(mu4e-headers-mode mu4e-main-mode mu4e-view-mode org-agenda-mode)))
      (if (memq major-mode modes) "~/Sync/notes")))
                                        ; (push 'zjn-projectile-root-for-some-major-modes projectile-project-root-files-functions))
  (setq +workspaces-on-switch-project-behavior t)
  )
#+end_src
** Coding
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.2))
(remove-hook 'doom-first-buffer-hook #'smartparens-global-mode)
(setq display-line-numbers-type nil)
#+end_src

Make sure shells stay live:

#+begin_src emacs-lisp
(after! shell
  (set-popup-rule! "^\\*shell\\*" :quit nil))
#+end_src
*** Working remote
#+begin_src emacs-lisp
(setq tramp-inline-compress-start-size 1000000)
#+end_src

*** Inheritenv
#+begin_src emacs-lisp
(require 'inheritenv)
(require 'format-all)
(inheritenv-add-advice 'call-process-region)
(inheritenv-add-advice 'call-process)
(inheritenv-add-advice 'shell-command)
(inheritenv-add-advice 'format-all--buffer-thunk)
#+end_src
*** Rust
#+begin_src emacs-lisp
(after! rustic
  (setq rustic-lsp-server 'rust-analyzer)
  (inheritenv-add-advice 'rustic-format-start-process)
  (inheritenv-add-advice 'rustic-compilation)
  (map! :map (conf-toml-mode-map rustic-mode-map)
        :localleader
        (:prefix ("c" . "cargo")
         :desc "cargo audit"    "a" #'+rust/cargo-audit
         :desc "cargo build"    "b" #'rustic-cargo-build
         :desc "cargo bench"    "B" #'rustic-cargo-bench
         :desc "cargo check"    "c" #'rustic-cargo-check
         :desc "cargo clippy"   "C" #'rustic-cargo-clippy
         :desc "cargo doc"      "d" #'rustic-cargo-doc
         :desc "cargo fmt"      "f" #'rustic-cargo-fmt
         :desc "cargo new"      "n" #'rustic-cargo-new
         :desc "cargo outdated" "o" #'rustic-cargo-outdated
         :desc "cargo run"      "r" #'rustic-cargo-run)
        (:prefix ("t" . "cargo test")
         :desc "all"          "a" #'rustic-cargo-test
         :desc "current test" "t" #'rustic-cargo-current-test)))
#+end_src
*** Python
#+begin_src emacs-lisp
(after! python-mode
  ; (inheritenv-add-advice ))
  )
#+end_src
*** Golang
#+begin_src emacs-lisp
(after! go
  (inheritenv-add-advice 'gofmt-before-save))
#+end_src
*** LSP
Don't watch ~.gitignore~ files ([[https://github.com/emacs-lsp/lsp-mode/issues/713][lsp-mode#713]]):
#+begin_src emacs-lisp
(after! lsp
  (defun ++git-ignore-p (path)
    (let* (; trailing / breaks git check-ignore if path is a symlink:
           (path (directory-file-name path))
           (default-directory (file-name-directory path))
           (relpath (file-name-nondirectory path))
           (cmd (format "git check-ignore '%s'" relpath))
           (status (call-process-shell-command cmd)))
      (eq status 0)))

  (defun ++lsp--path-is-watchable-directory-a
      (fn path dir ignored-directories)
    (and (not (++git-ignore-p (f-join dir path)))
         (funcall fn path dir ignored-directories)))

  (advice-add 'lsp--path-is-watchable-directory
              :around #'++lsp--path-is-watchable-directory-a))
#+end_src
** Authoring
#+begin_src emacs-lisp
(after! latex
  (add-to-list 'TeX-command-list '("Tectonic" "tectonic --synctex %t" TeX-run-compile nil (latex-mode) :help "Run Tectonic"))
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-view-program-list '(("PDF Tools" TeX-pdf-tools-sync-view))
        TeX-output-extension "pdf")
  (add-hook! LaTeX-mode
    (setq TeX-command-default "Tectonic"
          TeX-output-extension "pdf")))
#+end_src
** Reading
Good readers take notes; great readers don't exit their PDFs and lose all those notes.
#+begin_src emacs-lisp
(after! pdf-view
  (require 'inheritenv)
  (inheritenv-add-advice 'pdf-annot-print-annotation)
  (defun zjn/save-buffer-no-args () (save-buffer)) ; needed to make args line up
  (advice-add 'pdf-annot-edit-contents-commit :after 'zjn/save-buffer-no-args))
#+end_src
